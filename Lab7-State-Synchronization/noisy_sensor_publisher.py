"""
Lab 7: State Synchronization and Estimation - Noisy Sensor Publisher
======================================================================

Simulates a noisy sensor by reading from 'ground_truth.csv', adding random
noise, and publishing the data in real-time over MQTT.

This script acts as the "physical sensor" that measures the real motor's
angular velocity. Like all real sensors, it has measurement noise.

The Digital Twin will subscribe to this noisy data and use it to correct
its internal model, demonstrating sensor fusion and state estimation.

Prerequisites:
    - paho-mqtt library: pip install paho-mqtt
    - pandas: pip install pandas
    - numpy: pip install numpy
    - Running MQTT broker (e.g., Mosquitto)
    - ground_truth.csv file (generated by ground_truth_motor.py)

Usage:
    1. Ensure Mosquitto broker is running: mosquitto -v
    2. Ensure ground_truth.csv exists: python ground_truth_motor.py
    3. Run this publisher: python noisy_sensor_publisher.py
    4. In another terminal, run: python motor_digital_twin.py
"""

import paho.mqtt.client as mqtt
import pandas as pd
import numpy as np
import time
import json
from datetime import datetime
import sys
import os


# ========================================================================================
# CONFIGURATION
# ========================================================================================

# MQTT Broker Configuration
BROKER_ADDRESS = "localhost"
PORT = 1883

# MQTT Topic
TOPIC = "digital_twin/motor/sensor/angular_velocity"

# Sensor Configuration
SENSOR_ID = "VELOCITY_ENCODER_001"

# Noise Parameters
# Real sensors always have measurement noise due to:
# - Electronic noise in the measurement circuit
# - Quantization error in ADC
# - Environmental interference
# - Mechanical vibrations
NOISE_STD_DEV = 5.0  # Standard deviation of measurement noise (rad/s)
                      # This represents a reasonably noisy sensor

# Input file
INPUT_FILE = "ground_truth.csv"

# Playback speed multiplier
# 1.0 = real-time, 2.0 = 2x speed, 0.5 = half speed
PLAYBACK_SPEED = 1.0


# ========================================================================================
# MQTT CLIENT SETUP
# ========================================================================================

# Create MQTT client
client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION1, "NoisySensorPublisher")

def on_connect(client, userdata, flags, rc):
    """Callback when client connects to broker."""
    if rc == 0:
        print(f"✓ Connected to MQTT broker at {BROKER_ADDRESS}:{PORT}")
        print(f"  Publishing to topic: {TOPIC}")
        print(f"  Sensor ID: {SENSOR_ID}")
        print(f"  Noise level: σ = {NOISE_STD_DEV} rad/s")
    else:
        print(f"✗ Connection failed with code {rc}")

def on_publish(client, userdata, mid):
    """Callback when message is published."""
    pass  # We'll handle logging in the main loop

# Assign callbacks
client.on_connect = on_connect
client.on_publish = on_publish


# ========================================================================================
# DATA LOADING
# ========================================================================================

def load_ground_truth():
    """
    Load the ground truth dataset from CSV.

    Returns:
        DataFrame: Ground truth data
    """
    if not os.path.exists(INPUT_FILE):
        print(f"\n✗ Error: {INPUT_FILE} not found!")
        print(f"  Please run 'python ground_truth_motor.py' first to generate the data.")
        sys.exit(1)

    try:
        df = pd.read_csv(INPUT_FILE)
        required_columns = ['time', 'angular_velocity', 'voltage', 'current']

        for col in required_columns:
            if col not in df.columns:
                raise ValueError(f"Missing required column: {col}")

        return df

    except Exception as e:
        print(f"\n✗ Error loading {INPUT_FILE}: {e}")
        sys.exit(1)


# ========================================================================================
# SENSOR SIMULATION
# ========================================================================================

def add_sensor_noise(true_value, noise_std):
    """
    Add Gaussian (normal) noise to simulate sensor measurement error.

    Args:
        true_value: The true angular velocity
        noise_std: Standard deviation of the noise

    Returns:
        float: Noisy measurement
    """
    # Gaussian noise with mean=0 and std=noise_std
    noise = np.random.normal(0, noise_std)
    noisy_value = true_value + noise

    return noisy_value


def create_sensor_payload(timestamp, true_velocity, noisy_velocity, voltage):
    """
    Create JSON payload for sensor reading.

    Args:
        timestamp: Simulation time
        true_velocity: True angular velocity (for reference/debugging)
        noisy_velocity: Measured (noisy) angular velocity
        voltage: Input voltage (for Digital Twin to use)

    Returns:
        str: JSON-formatted payload
    """
    payload = {
        "timestamp": timestamp,
        "sensor_id": SENSOR_ID,
        "measured_velocity": noisy_velocity,
        "voltage": voltage,  # Digital Twin needs to know the input
        "metadata": {
            "true_velocity": true_velocity,  # For analysis/debugging only
            "noise_std_dev": NOISE_STD_DEV,
            "unit": "rad/s"
        }
    }

    return json.dumps(payload)


# ========================================================================================
# MAIN PUBLISHING LOOP
# ========================================================================================

def main():
    """
    Main function: Load data and publish sensor readings in real-time.
    """
    print("\n" + "="*70)
    print("NOISY SENSOR PUBLISHER - Simulated Motor Velocity Sensor")
    print("="*70)

    # Load ground truth data
    print(f"\nLoading ground truth data from {INPUT_FILE}...")
    df = load_ground_truth()

    print(f"✓ Loaded {len(df)} data points")
    print(f"  Time span: {df['time'].min():.2f}s to {df['time'].max():.2f}s")
    print(f"  Velocity range: {df['angular_velocity'].min():.2f} to {df['angular_velocity'].max():.2f} rad/s")

    # Connect to MQTT broker
    try:
        client.connect(BROKER_ADDRESS, PORT)
        client.loop_start()
        time.sleep(1)  # Allow connection to establish

    except Exception as e:
        print(f"\n✗ Failed to connect to broker: {e}")
        print(f"  Is Mosquitto running? Try: mosquitto -v")
        return

    # Publishing loop
    print("\n" + "-"*70)
    print("Publishing sensor data... (Press Ctrl+C to stop)")
    print("-"*70 + "\n")

    try:
        message_count = 0
        start_wall_time = time.time()
        start_sim_time = df['time'].iloc[0]

        # Iterate through DataFrame rows
        for idx, row in df.iterrows():
            # Extract data
            sim_time = row['time']
            true_velocity = row['angular_velocity']
            voltage = row['voltage']

            # Add sensor noise
            noisy_velocity = add_sensor_noise(true_velocity, NOISE_STD_DEV)

            # Create payload
            payload = create_sensor_payload(sim_time, true_velocity, noisy_velocity, voltage)

            # Publish
            result = client.publish(TOPIC, payload, qos=0)
            message_count += 1

            # Display progress
            noise_error = noisy_velocity - true_velocity
            print(f"[t={sim_time:6.2f}s] Message #{message_count:3d}")
            print(f"  True velocity:   {true_velocity:8.2f} rad/s")
            print(f"  Noisy reading:   {noisy_velocity:8.2f} rad/s (error: {noise_error:+7.2f})")
            print(f"  Voltage input:   {voltage:8.2f} V")

            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                print(f"  Status: ✓ Published")
            else:
                print(f"  Status: ✗ Failed (code {result.rc})")

            print()

            # Real-time pacing: Sleep until next data point
            if idx < len(df) - 1:
                # Calculate time until next sample
                next_sim_time = df.loc[idx + 1, 'time']
                time_delta = next_sim_time - sim_time

                # Adjust for playback speed
                sleep_time = time_delta / PLAYBACK_SPEED

                # Account for processing time
                elapsed_wall_time = time.time() - start_wall_time
                expected_wall_time = (sim_time - start_sim_time) / PLAYBACK_SPEED
                drift = expected_wall_time - elapsed_wall_time

                # Adjust sleep to stay synchronized
                adjusted_sleep = max(0, sleep_time + drift)

                if adjusted_sleep > 0:
                    time.sleep(adjusted_sleep)

    except KeyboardInterrupt:
        # Clean shutdown
        print("\n" + "="*70)
        print("Shutting down sensor publisher...")
        print(f"Total messages published: {message_count}")
        print("="*70 + "\n")

    except Exception as e:
        print(f"\n✗ Unexpected error: {e}")

    finally:
        # Disconnect
        client.loop_stop()
        client.disconnect()
        print("✓ Disconnected from broker. Goodbye!\n")


# ========================================================================================
# SCRIPT EXECUTION
# ========================================================================================

if __name__ == "__main__":
    main()
