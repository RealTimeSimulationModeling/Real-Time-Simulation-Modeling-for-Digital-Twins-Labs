"""
Lab 5: Twinning a DC Motor - Physics-Based Digital Twin
=======================================================

This script implements a physics-based, continuous-time simulation of a DC motor
using ordinary differential equations (ODEs). It demonstrates the complete Digital
Twin development workflow: modeling, calibration, validation, and virtual sensing.

Physics-Based Modeling Concepts:
    - State-space representation using ODEs
    - Coupled electrical-mechanical-thermal domains
    - First-principles modeling from physical laws
    - Numerical ODE solving with scipy
    - Model calibration and parameter identification
    - Virtual sensing for unmeasurable quantities

Three-Part Structure:
    1. Build the Model: Implement ODE system from first principles
    2. Calibrate & Validate: Tune parameters to match real data
    3. Virtual Sensor: Estimate internal temperature (unmeasurable)

Physical Domains:
    - Electrical: Armature circuit dynamics
    - Mechanical: Rotor dynamics
    - Thermal: Heat generation and dissipation
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from dataclasses import dataclass

# ========================================================================================
# PHASE 1: PHYSICS-BASED MODEL - PARAMETER DEFINITIONS
# ========================================================================================

@dataclass
class DCMotorParameters:
    """
    Physical parameters of the DC motor.

    These represent the motor's intrinsic properties and can be:
    - Measured directly (e.g., R with an ohmmeter)
    - Obtained from manufacturer datasheets
    - Identified through calibration experiments
    """

    # ================================================================================
    # ELECTRICAL DOMAIN PARAMETERS
    # ================================================================================
    R: float = 1.0      # Armature resistance (Ohms)
                        # Represents resistive losses in the motor windings

    L: float = 0.5      # Armature inductance (Henries)
                        # Represents energy storage in magnetic field
                        # Causes current to lag voltage changes

    L_e: float = 0.01   # Back-EMF constant (V·s/rad)
                        # Voltage generated by spinning motor (opposes applied voltage)
                        # Proportional to angular velocity

    # ================================================================================
    # MECHANICAL DOMAIN PARAMETERS
    # ================================================================================
    J: float = 0.01     # Moment of inertia (kg·m²)
                        # Resistance to angular acceleration
                        # Includes rotor + any attached load

    b: float = 0.1      # Viscous friction coefficient (N·m·s/rad)
                        # Damping torque proportional to speed
                        # Includes bearing friction, air resistance

    K_t: float = 0.01   # Torque constant (N·m/A)
                        # Torque produced per unit current
                        # In SI units, K_t ≈ L_e (but independent parameter for generality)

    # ================================================================================
    # THERMAL DOMAIN PARAMETERS
    # ================================================================================
    R_th: float = 1.5   # Thermal resistance (°C/W)
                        # Resistance to heat flow from motor to environment
                        # Higher = slower cooling

    C_th: float = 10.0  # Thermal capacitance (J/°C)
                        # Heat capacity of motor mass
                        # Higher = slower temperature changes

    T_ambient: float = 25.0  # Ambient temperature (°C)
                             # Environmental temperature


# Create initial parameter set (will be tuned during calibration)
params_initial_guess = DCMotorParameters(
    R=1.0,
    L=0.5,
    J=0.01,
    b=0.1,
    K_t=0.01,
    L_e=0.01,
    R_th=1.5,
    C_th=10.0,
    T_ambient=25.0
)

# "True" parameters (used to generate synthetic "real" data)
# In practice, these would come from actual motor measurements
params_true = DCMotorParameters(
    R=1.2,      # Slightly different from guess
    L=0.45,
    J=0.012,
    b=0.15,
    K_t=0.012,
    L_e=0.012,
    R_th=1.8,
    C_th=12.0,
    T_ambient=25.0
)


# ========================================================================================
# PHASE 1: PHYSICS-BASED MODEL - ODE SYSTEM
# ========================================================================================

def dc_motor_model(t, y, voltage_func, params):
    """
    Defines the system of ODEs governing DC motor behavior.

    This function implements the coupled electrical-mechanical-thermal dynamics
    based on first-principles physics.

    State Variables (y):
        y[0] = ω (omega): Angular velocity (rad/s)
        y[1] = i: Armature current (A)
        y[2] = T: Motor temperature (°C)

    Args:
        t: Current time (s)
        y: State vector [ω, i, T]
        voltage_func: Function that returns applied voltage at time t
        params: DCMotorParameters object with physical constants

    Returns:
        dy/dt: Time derivatives [dω/dt, di/dt, dT/dt]

    Physics:
        1. Electrical: Kirchhoff's Voltage Law on armature circuit
        2. Mechanical: Newton's 2nd Law for rotation
        3. Thermal: Lumped-parameter heat transfer model
    """
    # Unpack state variables
    omega = y[0]  # Angular velocity (rad/s)
    i = y[1]      # Armature current (A)
    temp = y[2]   # Temperature (°C)

    # Get input voltage at current time
    V = voltage_func(t)

    # ================================================================================
    # ELECTRICAL DYNAMICS (Kirchhoff's Voltage Law)
    # ================================================================================
    # Applied voltage = Resistive drop + Inductive drop + Back-EMF
    # V = R*i + L*(di/dt) + L_e*ω
    #
    # Solving for di/dt:
    # di/dt = (V - R*i - L_e*ω) / L
    #
    # Physical interpretation:
    # - Applied voltage V drives current increase
    # - Resistance R opposes current (I²R losses)
    # - Back-EMF (L_e*ω) opposes current as motor spins faster
    # - Inductance L slows current changes (energy stored in magnetic field)

    di_dt = (V - params.R * i - params.L_e * omega) / params.L

    # ================================================================================
    # MECHANICAL DYNAMICS (Newton's 2nd Law for Rotation)
    # ================================================================================
    # Net torque = Moment of inertia × Angular acceleration
    # T_net = J * (dω/dt)
    #
    # T_net = T_motor - T_friction
    # T_motor = K_t * i  (electromagnetic torque)
    # T_friction = b * ω  (viscous damping)
    #
    # Solving for dω/dt:
    # dω/dt = (K_t*i - b*ω) / J
    #
    # Physical interpretation:
    # - Current i generates torque (K_t*i)
    # - Friction opposes motion (b*ω)
    # - Inertia J resists acceleration

    T_motor = params.K_t * i
    T_friction = params.b * omega

    domega_dt = (T_motor - T_friction) / params.J

    # ================================================================================
    # THERMAL DYNAMICS (Lumped Heat Transfer Model)
    # ================================================================================
    # Rate of temperature change = (Heat in - Heat out) / Thermal capacitance
    # dT/dt = (P_heat - Q_cooling) / C_th
    #
    # P_heat = R * i²  (Joule heating in armature resistance)
    # Q_cooling = (T - T_ambient) / R_th  (Newton's law of cooling)
    #
    # Physical interpretation:
    # - I²R losses generate heat
    # - Temperature difference drives heat flow to environment
    # - Thermal mass C_th slows temperature changes
    # - Thermal resistance R_th limits cooling rate

    P_heat = params.R * i**2  # Electrical power dissipated as heat (W)
    Q_cooling = (temp - params.T_ambient) / params.R_th  # Heat flow to environment (W)

    dtemp_dt = (P_heat - Q_cooling) / params.C_th

    # Return derivatives
    return [domega_dt, di_dt, dtemp_dt]


# ========================================================================================
# PHASE 2: GENERATE "REAL" DATA FOR VALIDATION
# ========================================================================================

def generate_real_data():
    """
    Generate synthetic "measured" data from a real motor.

    In practice, this data would come from:
    - Angular velocity: Encoder or tachometer
    - Voltage: Voltage sensor
    - Current: Current sensor (optional, for more validation)

    We use the "true" parameters to simulate a real motor's response,
    then add measurement noise to make it realistic.

    Returns:
        time_real: Time points (s)
        voltage_real: Applied voltage (V)
        omega_real: Measured angular velocity (rad/s) with noise
        current_real: Measured current (A) with noise
    """
    print("Generating synthetic 'real' motor data...")

    # Time span for experiment
    t_span = (0, 10)  # 10 seconds
    t_eval = np.linspace(0, 10, 1000)

    # Define voltage input profile
    # Step input: 0V for first 2 seconds, then 12V
    def voltage_input(t):
        return 12.0 if t >= 2.0 else 0.0

    # Initial conditions: motor at rest, room temperature
    y0 = [0.0, 0.0, params_true.T_ambient]  # [ω, i, T]

    # Solve ODEs with TRUE parameters (simulates real motor)
    solution = solve_ivp(
        fun=lambda t, y: dc_motor_model(t, y, voltage_input, params_true),
        t_span=t_span,
        y0=y0,
        t_eval=t_eval,
        method='RK45',  # Runge-Kutta 4th/5th order (good accuracy)
        rtol=1e-6,      # Relative tolerance
        atol=1e-9       # Absolute tolerance
    )

    # Extract solution
    time_real = solution.t
    omega_real = solution.y[0, :]
    current_real = solution.y[1, :]

    # Add measurement noise to simulate real sensors
    # Encoders typically have ~1% noise at high speeds
    noise_omega = np.random.normal(0, 0.5, len(omega_real))
    omega_real_noisy = omega_real + noise_omega

    # Current sensors might have ~2% noise
    noise_current = np.random.normal(0, 0.02, len(current_real))
    current_real_noisy = current_real + noise_current

    # Voltage is clean (assuming good power supply)
    voltage_real = np.array([voltage_input(t) for t in time_real])

    print(f"  Generated {len(time_real)} data points over {t_span[1]} seconds")
    print(f"  Peak velocity: {np.max(omega_real_noisy):.2f} rad/s")
    print(f"  Peak current: {np.max(current_real_noisy):.2f} A")

    return time_real, voltage_real, omega_real_noisy, current_real_noisy


# ========================================================================================
# PHASE 2: RUN SIMULATION WITH STUDENT'S PARAMETERS
# ========================================================================================

def simulate_motor(params, t_span, t_eval, voltage_func, y0=None):
    """
    Simulate the DC motor with given parameters.

    Args:
        params: DCMotorParameters object
        t_span: Tuple (t_start, t_end)
        t_eval: Time points for solution output
        voltage_func: Function V(t) for applied voltage
        y0: Initial conditions [ω, i, T] (default: motor at rest)

    Returns:
        solution: ODE solution object from solve_ivp
    """
    if y0 is None:
        y0 = [0.0, 0.0, params.T_ambient]

    solution = solve_ivp(
        fun=lambda t, y: dc_motor_model(t, y, voltage_func, params),
        t_span=t_span,
        y0=y0,
        t_eval=t_eval,
        method='RK45',
        rtol=1e-6,
        atol=1e-9
    )

    return solution


# ========================================================================================
# PHASE 2: MODEL CALIBRATION HELPER
# ========================================================================================

def calculate_rmse(predicted, measured):
    """
    Calculate Root Mean Square Error between predicted and measured values.

    This is a common metric for model validation.
    Lower RMSE = better fit.

    Args:
        predicted: Model output
        measured: Real data

    Returns:
        RMSE value
    """
    return np.sqrt(np.mean((predicted - measured)**2))


def evaluate_model_fit(time_real, omega_real, params, voltage_func):
    """
    Evaluate how well the model fits real data with given parameters.

    Args:
        time_real: Time points from real data
        omega_real: Measured angular velocity
        params: Parameters to evaluate
        voltage_func: Voltage input function

    Returns:
        rmse: Root mean square error
        omega_sim: Simulated angular velocity
    """
    # Simulate with these parameters
    solution = simulate_motor(params, (time_real[0], time_real[-1]), time_real, voltage_func)
    omega_sim = solution.y[0, :]

    # Calculate error
    rmse = calculate_rmse(omega_sim, omega_real)

    return rmse, omega_sim


# ========================================================================================
# PHASE 3: VISUALIZATION
# ========================================================================================

def plot_validation(time, voltage, omega_real, omega_sim, current_real=None, current_sim=None):
    """
    Plot validation results: compare simulated vs. measured data.

    Args:
        time: Time vector
        voltage: Applied voltage
        omega_real: Measured angular velocity
        omega_sim: Simulated angular velocity
        current_real: Measured current (optional)
        current_sim: Simulated current (optional)
    """
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    fig.suptitle('DC Motor Model Validation: Simulation vs. Real Data',
                 fontsize=14, fontweight='bold')

    # ================================================================================
    # PLOT 1: INPUT VOLTAGE
    # ================================================================================
    ax1 = axes[0]
    ax1.plot(time, voltage, 'k-', linewidth=2, label='Applied Voltage')
    ax1.set_ylabel('Voltage (V)', fontsize=11)
    ax1.set_title('Input: Applied Voltage', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.set_xlim([time[0], time[-1]])

    # ================================================================================
    # PLOT 2: ANGULAR VELOCITY (KEY VALIDATION METRIC)
    # ================================================================================
    ax2 = axes[1]
    ax2.plot(time, omega_real, 'b.', markersize=3, alpha=0.5, label='Measured (Real Motor)')
    ax2.plot(time, omega_sim, 'r-', linewidth=2, label='Simulated (Model)')
    ax2.set_ylabel('Angular Velocity (rad/s)', fontsize=11)
    ax2.set_title('Validation: Angular Velocity Comparison', fontsize=12, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    ax2.set_xlim([time[0], time[-1]])

    # Calculate and display RMSE
    rmse = calculate_rmse(omega_sim, omega_real)
    ax2.text(0.02, 0.95, f'RMSE = {rmse:.3f} rad/s',
             transform=ax2.transAxes, fontsize=10,
             verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

    # ================================================================================
    # PLOT 3: CURRENT (IF AVAILABLE)
    # ================================================================================
    ax3 = axes[2]
    if current_real is not None and current_sim is not None:
        ax3.plot(time, current_real, 'g.', markersize=3, alpha=0.5, label='Measured Current')
        ax3.plot(time, current_sim, 'm-', linewidth=2, label='Simulated Current')
        ax3.set_ylabel('Current (A)', fontsize=11)
        ax3.set_title('Additional Validation: Armature Current', fontsize=12, fontweight='bold')
        rmse_current = calculate_rmse(current_sim, current_real)
        ax3.text(0.02, 0.95, f'RMSE = {rmse_current:.3f} A',
                 transform=ax3.transAxes, fontsize=10,
                 verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    else:
        ax3.text(0.5, 0.5, 'Current data not available',
                 ha='center', va='center', transform=ax3.transAxes, fontsize=12)
    ax3.set_xlabel('Time (s)', fontsize=11)
    ax3.set_ylabel('Current (A)', fontsize=11)
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    ax3.set_xlim([time[0], time[-1]])

    plt.tight_layout()
    plt.savefig('dc_motor_validation.png', dpi=150, bbox_inches='tight')
    print("\n✓ Validation plot saved as 'dc_motor_validation.png'")


def plot_virtual_sensor(time, current, temperature):
    """
    Plot virtual sensor results: current and estimated temperature.

    The temperature is a VIRTUAL SENSOR - we cannot measure it directly
    in a real motor without thermocouples embedded inside. The physics-based
    model allows us to estimate it from measurable quantities (voltage, current).

    Args:
        time: Time vector
        current: Armature current
        temperature: Estimated motor temperature
    """
    fig, axes = plt.subplots(2, 1, figsize=(12, 8))
    fig.suptitle('Virtual Sensor: Internal Motor Temperature Estimation',
                 fontsize=14, fontweight='bold')

    # ================================================================================
    # PLOT 1: ARMATURE CURRENT
    # ================================================================================
    ax1 = axes[0]
    ax1.plot(time, current, 'b-', linewidth=2, label='Armature Current')
    ax1.set_ylabel('Current (A)', fontsize=11)
    ax1.set_title('Measured: Armature Current', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.set_xlim([time[0], time[-1]])

    # Annotate peak current
    peak_current = np.max(current)
    peak_time = time[np.argmax(current)]
    ax1.annotate(f'Peak: {peak_current:.2f} A',
                xy=(peak_time, peak_current),
                xytext=(peak_time + 1, peak_current - 0.5),
                arrowprops=dict(arrowstyle='->', color='red'),
                fontsize=10, color='red')

    # ================================================================================
    # PLOT 2: TEMPERATURE (VIRTUAL SENSOR!)
    # ================================================================================
    ax2 = axes[1]
    ax2.plot(time, temperature, 'r-', linewidth=2, label='Estimated Temperature')
    ax2.axhline(y=params_true.T_ambient, color='green', linestyle='--',
                linewidth=1.5, label=f'Ambient ({params_true.T_ambient}°C)')
    ax2.set_xlabel('Time (s)', fontsize=11)
    ax2.set_ylabel('Temperature (°C)', fontsize=11)
    ax2.set_title('Virtual Sensor: Internal Temperature (Unmeasurable)',
                  fontsize=12, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    ax2.set_xlim([time[0], time[-1]])

    # Annotate final temperature
    final_temp = temperature[-1]
    temp_rise = final_temp - params_true.T_ambient
    ax2.annotate(f'Final: {final_temp:.1f}°C\n(+{temp_rise:.1f}°C)',
                xy=(time[-1], final_temp),
                xytext=(time[-1] - 2, final_temp + 5),
                arrowprops=dict(arrowstyle='->', color='darkred'),
                fontsize=10, color='darkred',
                bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.7))

    # Warning threshold
    max_safe_temp = 80.0
    if final_temp > max_safe_temp:
        ax2.axhline(y=max_safe_temp, color='red', linestyle=':', linewidth=2,
                    label=f'Warning Threshold ({max_safe_temp}°C)')
        ax2.fill_between(time, max_safe_temp, ax2.get_ylim()[1],
                         color='red', alpha=0.1)
        ax2.legend()

    plt.tight_layout()
    plt.savefig('dc_motor_virtual_sensor.png', dpi=150, bbox_inches='tight')
    print("✓ Virtual sensor plot saved as 'dc_motor_virtual_sensor.png'")


# ========================================================================================
# MAIN EXECUTION
# ========================================================================================

def main():
    """
    Main execution: complete Digital Twin workflow.

    Workflow:
        1. Generate synthetic "real" data
        2. Calibrate model parameters (simulated manual tuning)
        3. Validate model against real data
        4. Use validated model as virtual sensor for temperature
    """
    print("\n")
    print("╔" + "═"*76 + "╗")
    print("║" + " "*76 + "║")
    print("║" + "  LAB 5: DC MOTOR DIGITAL TWIN - PHYSICS-BASED MODELING".center(76) + "║")
    print("║" + "  Demonstrating ODE Modeling, Calibration, and Virtual Sensing".center(76) + "║")
    print("║" + " "*76 + "║")
    print("╚" + "═"*76 + "╝")

    # ================================================================================
    # STEP 1: GENERATE "REAL" DATA
    # ================================================================================
    print("\n" + "="*80)
    print("STEP 1: GENERATING 'REAL' MOTOR DATA")
    print("="*80)

    time_real, voltage_real, omega_real, current_real = generate_real_data()

    # Define voltage function for simulation
    def voltage_func(t):
        return 12.0 if t >= 2.0 else 0.0

    # ================================================================================
    # STEP 2: INITIAL MODEL RUN (BEFORE CALIBRATION)
    # ================================================================================
    print("\n" + "="*80)
    print("STEP 2: INITIAL MODEL EVALUATION (Before Calibration)")
    print("="*80)

    rmse_initial, omega_sim_initial = evaluate_model_fit(
        time_real, omega_real, params_initial_guess, voltage_func
    )

    print(f"\nInitial RMSE: {rmse_initial:.4f} rad/s")
    print("→ Model doesn't match data well yet. Calibration needed!")

    # ================================================================================
    # STEP 3: CALIBRATED MODEL (SIMULATED TUNING)
    # ================================================================================
    print("\n" + "="*80)
    print("STEP 3: MODEL CALIBRATION")
    print("="*80)
    print("\nIn practice, you would manually adjust parameters or use optimization.")
    print("For this demo, we'll use parameters close to the 'true' values...\n")

    # Calibrated parameters (simulating successful manual tuning)
    params_calibrated = DCMotorParameters(
        R=1.18,   # Close to true: 1.2
        L=0.47,   # Close to true: 0.45
        J=0.0118, # Close to true: 0.012
        b=0.14,   # Close to true: 0.15
        K_t=0.0118,
        L_e=0.0118,
        R_th=1.75,
        C_th=11.5,
        T_ambient=25.0
    )

    rmse_calibrated, omega_sim_calibrated = evaluate_model_fit(
        time_real, omega_real, params_calibrated, voltage_func
    )

    print(f"Calibrated RMSE: {rmse_calibrated:.4f} rad/s")
    print(f"Improvement: {(1 - rmse_calibrated/rmse_initial)*100:.1f}% reduction in error")
    print("→ Model now accurately represents the real motor!")

    # ================================================================================
    # STEP 4: VALIDATION VISUALIZATION
    # ================================================================================
    print("\n" + "="*80)
    print("STEP 4: MODEL VALIDATION")
    print("="*80)

    # Run full simulation with calibrated parameters
    solution_calibrated = simulate_motor(
        params_calibrated,
        (time_real[0], time_real[-1]),
        time_real,
        voltage_func
    )

    omega_sim = solution_calibrated.y[0, :]
    current_sim = solution_calibrated.y[1, :]
    temp_sim = solution_calibrated.y[2, :]

    print("\nGenerating validation plots...")
    plot_validation(time_real, voltage_real, omega_real, omega_sim,
                   current_real, current_sim)

    # ================================================================================
    # STEP 5: VIRTUAL SENSOR
    # ================================================================================
    print("\n" + "="*80)
    print("STEP 5: VIRTUAL SENSOR - TEMPERATURE ESTIMATION")
    print("="*80)
    print("\nThe validated model can now estimate UNMEASURABLE quantities!")
    print("Temperature is difficult to measure inside a running motor,")
    print("but our physics-based model can estimate it from voltage and current.\n")

    print(f"Temperature Profile:")
    print(f"  Initial: {temp_sim[0]:.1f}°C (ambient)")
    print(f"  Peak: {np.max(temp_sim):.1f}°C")
    print(f"  Final: {temp_sim[-1]:.1f}°C")
    print(f"  Temperature rise: {temp_sim[-1] - temp_sim[0]:.1f}°C")

    if temp_sim[-1] > 60:
        print("\n⚠️  WARNING: Motor running hot! Consider:")
        print("  - Reducing duty cycle")
        print("  - Improving cooling")
        print("  - Checking for mechanical issues")
    else:
        print("\n✓ Motor temperature within safe range")

    print("\nGenerating virtual sensor plots...")
    plot_virtual_sensor(time_real, current_sim, temp_sim)

    # ================================================================================
    # SUMMARY
    # ================================================================================
    print("\n" + "="*80)
    print("DIGITAL TWIN CAPABILITIES DEMONSTRATED")
    print("="*80)
    print("\n1. PHYSICS-BASED MODELING")
    print("   ✓ Three-domain coupled ODEs (electrical, mechanical, thermal)")
    print("   ✓ First-principles equations from physical laws")
    print("   ✓ High-fidelity representation of real system")

    print("\n2. MODEL CALIBRATION & VALIDATION")
    print(f"   ✓ Initial RMSE: {rmse_initial:.4f} rad/s")
    print(f"   ✓ Calibrated RMSE: {rmse_calibrated:.4f} rad/s")
    print(f"   ✓ Improvement: {(1 - rmse_calibrated/rmse_initial)*100:.1f}%")

    print("\n3. VIRTUAL SENSING")
    print("   ✓ Estimated internal temperature (not directly measurable)")
    print(f"   ✓ Predicted temperature rise: {temp_sim[-1] - temp_sim[0]:.1f}°C")
    print("   ✓ Can predict thermal limits before physical damage")

    print("\n4. DIGITAL TWIN APPLICATIONS")
    print("   • Predictive Maintenance: Forecast when motor will overheat")
    print("   • Control Optimization: Tune control law to minimize heat")
    print("   • Design Iteration: Test modifications virtually before building")
    print("   • Anomaly Detection: Detect degradation from model deviation")

    print("\n" + "="*80)
    print("Lab 5 Complete! Physics-based Digital Twin demonstrated.")
    print("="*80 + "\n")

    plt.show()


if __name__ == "__main__":
    main()
